import { log } from '../../common/log';
import { getGitLabService } from '../gitlab/get_gitlab_service';
import { ProjectInRepository } from '../gitlab/new_project';
import { GqlDiffPositionInput } from '../gitlab/graphql/create_diff_comment';
import { ReviewComment, MRReviewContext } from './types';

/**
 * åœ¨ GitLab MR ä¸Šåˆ›å»º AI Review è¯„è®º
 */

/**
 * ä¸º AI Review ç»“æœåˆ›å»º GitLab è¯„è®º
 * @param comments Review è¯„è®ºåˆ—è¡¨
 * @param context MR Review ä¸Šä¸‹æ–‡
 * @param projectInRepository é¡¹ç›®ä¿¡æ¯
 * @returns æˆåŠŸåˆ›å»ºçš„è¯„è®ºæ•°é‡
 */
export async function createReviewComments(
  comments: ReviewComment[],
  context: MRReviewContext,
  projectInRepository: ProjectInRepository,
): Promise<number> {
  const gitLabService = getGitLabService(projectInRepository);
  let successCount = 0;

  // eslint-disable-next-line no-restricted-syntax
  for (const comment of comments) {
    try {
      // eslint-disable-next-line no-await-in-loop
      await createSingleComment(comment, context, gitLabService);
      successCount += 1;
      log.info(`Created review comment on ${comment.filePath}:${comment.lineNumber}`);
    } catch (error) {
      log.error(`Failed to create comment on ${comment.filePath}:${comment.lineNumber}: ${error}`);
    }
  }

  log.info(`Successfully created ${successCount}/${comments.length} review comments`);
  return successCount;
}

/**
 * åˆ›å»ºå•ä¸ª review è¯„è®º
 */
async function createSingleComment(
  comment: ReviewComment,
  context: MRReviewContext,
  gitLabService: ReturnType<typeof getGitLabService>,
): Promise<void> {
  // æ‰¾åˆ°å¯¹åº”çš„ diff
  const diff = context.diffs.find((d) => d.filePath === comment.filePath);
  if (!diff) {
    throw new Error(`Diff not found for file: ${comment.filePath}`);
  }

  // æ„å»ºè¯„è®ºå†…å®¹ï¼ŒåŒ…å«ä¸¥é‡ç¨‹åº¦æ ‡è®°
  const commentBody = formatCommentBody(comment);

  // æ„å»º diff position
  const position: GqlDiffPositionInput = {
    baseSha: context.baseSha,
    headSha: context.headSha,
    startSha: context.startSha,
    paths: {
      oldPath: diff.oldPath || diff.newPath,
      newPath: diff.newPath,
    },
    newLine: comment.lineNumber,
  };

  // å¦‚æœæœ‰æ—§è¡Œå·ï¼Œä¹Ÿæ·»åŠ 
  if (comment.oldLineNumber) {
    position.oldLine = comment.oldLineNumber;
  }

  // åˆ›å»º diff è¯„è®º
  await gitLabService.createDiffNote(context.mrId, commentBody, position);
}

/**
 * æ ¼å¼åŒ–è¯„è®ºå†…å®¹
 */
function formatCommentBody(comment: ReviewComment): string {
  const severityEmoji = {
    error: 'ğŸš¨',
    warning: 'âš ï¸',
    info: 'â„¹ï¸',
  };

  const emoji = severityEmoji[comment.severity] || 'â„¹ï¸';

  return `${emoji} **AI Code Review** (${comment.severity})

${comment.content}

---
*This comment was generated by GitLab Duo AI Code Review*`;
}
